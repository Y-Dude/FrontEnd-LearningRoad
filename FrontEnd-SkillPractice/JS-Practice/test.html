<html>

<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style type="text/css">
		#main {
			width: 200px;
			height: 200px;
			border: solid 5px red;
		}

		#div1 {
			width: 50px;
			height: 50px;
			float: right;
			border: solid 5px blue;
		}
	</style>
</head>

<body>
	<div id="main">
		<div id="div1">
		</div>
	</div>

	<script type="text/javascript">
		function say() {
			alert('hea');
		}
		say();


		// class my {
		// 	var name = 1;
		// 	var age = 2;
		// 	construct(name, age){
		// 		this.name = name;
		// 		this.age = age;
		// 	}
		// 	myFunction(){
		// 		alert('myFunction');
		// 	}
		// }
		// var myClass = new my();
		// myClass.myFunction();


		// 引用类型和值类型问题
		var a = { n: 1 };
		var b = a;
		a.x = a = { n: 2 };
		console.log(a.x);
		console.log(b.x);
		console.log(a);
		console.log(b);

		// 出现此问题的原因，，，
		// 1、在执行前，会先将a和a.x中的a的引用地址都取出来，此值他们都指向{ n: 1 }

		// 2、在内存中创建一个新对象{ n: 2 }

		// 3、执行a = { n: 2 }，将a的引用从指向{ n: 1 } 改为指向新的{ n: 2 }

		// 4、执行a.x = a，此时a已经指向了新对象，而a.x因为在执行前保留了原引用，所以a.x的a依然指向原先的{ n: 1 } 对象，所以给原对象新增一个属性x，内容为{ n: 2 } 也就是现在a

		// 5、语句执行结束，原对象由{ n: 1 } 变成{ n: 1, x: { n: 2 } } ，而原对象因为无人再引用他，所以被GC回收，当前a指向新对象{ n: 2 }

		// 6、所以就有了文章开头的运行结果，再执行a.x，自然就是undefined了
	</script>
</body>

</html>