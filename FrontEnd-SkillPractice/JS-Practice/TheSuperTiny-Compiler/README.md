# [The Super Tiny Compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)

## 基础概念
- AST （抽象语法树），或简称语法树，是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现(因为树的父子嵌套关系就已经表示了括号的概念)；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。
- 遍历/搜索：深度优先遍历，图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

## 编译工作的主要阶段（simple）

> 事实上，不是所有的编译器工作阶段都和此编译器类似。每个编译器都有不同的目的，所以他们可能有比这个编译器拥有更多的步骤。
1. 解析：把原始代码串 解析为 更加抽象的结构化表
    1. 词法分析(扫描程序)：把代码串转换成一系列词法单元（token，他可以是数字、标记、 标点符号、操作符等。），每个 token 被用标记器或者词法分析器来标识最终生成token序列（一组独立语法成分的描述）。
    2. 语法分析：把 token 重新格式化生成能够描述语法结构（包括语法成分及其关系）的中间表示形式/抽象语法树，抽象语法树（简称AST）是个深层嵌套的对象，易于处理并且携带着语法结构信息。
    3. 语义分析
2. 转换（优化程序，等价变换）：这个阶段，你可以用同样的语言对AST进行修改，也就是遍历上面生成的树结构，进行节点级操作（增/删/改节点）和属性级操作（增/删/改属性）。当然，也可以基于此树创建一棵全新新树翻译为新的语言（此时由于我们的目标是新语言，因此我们将专注于创建一个特定于目标语言的全新AST）。Here is where the miracle will happen.
    - 遍历：The Super Tiny Compiler,实现上采用深度优先遍历，把访问节点的操作提出来作为visitor层，遍历过程中按词法单元类型调用对应的enter/exit方法，遍历过程中通知visitor，有点切面的意思。
3. 代码生成：代码生成器以多种不同的方式工作,一些会重用之前的tokens，另一些则会创建一种新的代码表示方法以便他们可以线性的输出节点，此处我们会把AST生成代码字符串（该加分号的加分号，该添括号的添括号... ...）

### 整个流程
```javascript
function compiler(input) {
  let tokens = tokenizer(input);
  let ast    = parser(tokens);
  let newAst = transformer(ast);
  let output = codeGenerator(newAst);
  return output;
}
```