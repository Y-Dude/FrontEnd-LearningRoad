# 2018-07-20 周报

> ## 本周完成工作

- [x] 完成新人培训中期汇报，听取老师们的建议并及时改进 
- [x] 在不依赖第三方的情况下使用node启动一个简单的web服务器 
- [x] vue服务端渲染实现专题页同构，使用nuxt同构之前的专题页
- [x] 熟悉mock数据，使用mockjs模拟文章数据整合到vue项目

> ## 下周工作计划

- 完成一个完整的文章管理页面
    - 前端项目构建。熟悉脚手架命令及项目文件结构
    - 熟悉MongoDB，设计mongo存储的文章的数据结构
    - API设计，使用RESTFul API设计风格设计后端接口
    - 前后端联调，前端文章展示，后端管理文章（增删查改）

> ## 遇到的问题及解决

- 发现要启动一个完美的web服务器真的没这么简单，各种请求处理，各种文件MIME TYPE检查，默认文件读取，容错判断 etc. 突然感觉Apache服务器好厉害，只需简单地修改配置文件便可以开启一个web服务器，又可以解析多种语言(安装对应语言的编译器)。简直是一个很强大的“组件”。
- 本打算根据vue ssr教程使用vue-server-render+webpack+express实现服务端渲染项目的集成和构建配置，但最后还是无法驾驭，最后使用一个基于vue生态的更高层的框架Nuxt.js实现专题页的服务端渲染同构。
- Nuxt的static目录问题
    - 需要使用`~/static/`访问目录下文件
    - 动态加载的图片文件路径直接使用`/`访问，nuxt会指向`/static`下的相应图片
- nuxt根据pages下的文件目录自动生成路由
- *注意*我们需要为**每个**请求创建一个新的根 Vue 实例(router,store同理)。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染。因此，我们不应该直接创建*一个*应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例。

> ## 产出

- 简单的node本地web服务器
- 使用nuxt同构的专题页，各分类正常路由无刷新跳转，课程页新开单页渲染
- 使用mockjs实现文章数据模拟

> ## 学习与反思

- 前端渲染整个页面的渲染基本上都由前端js动态渲染，但这样对于一些应用来说是有缺陷的。比如需要 SEO 的，需要打开页面不用等待就能看到页面的等，解决这个问题暂时有以下思路：
    - 预渲染：无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时(build time)简单地生成针对特定路由的静态 HTML 文件。
    - 服务器端渲染(SSR)：将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。服务器渲染的 Vue.js 应用程序也可以被认为是"同构"或"通用"，因为应用程序的大部分代码都可以在服务器和客户端上运行。（next.js,nuxt.js）
    - node中间层：保留服务器端模板渲染的功能，但是由 node 程序来代替以往的后端语言进行模板渲染，后端语言与 node 程序只做数据交互。
- Mock数据两种思路
    - 在client端处数据mock：该方式拦截了请求的发出，直接返回mock的数据
    - 在server端mock：该方式请求真实地发出，只是在server端进行route拦截
- Mock数据的几种方式
    - 将mock数据直接写在代码里，设置定时器函数返回
    - 利用js拦截请求，例如使用Mock.js模拟ajax请求，生成并模拟Mock数据
    - 利用Charles和Fiddler等代理工具拦截请求
    - 使用Easy Mock,RAP等工具管理团队内多个项目的Mock数据
- vscode 添加代码片段减少重复工作 (感谢连飞老师)


> ## *Doggerel: 后端不来过夜半，闲敲mock落灯花。*