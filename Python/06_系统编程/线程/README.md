如果处于就绪状态的线程获得了 CPU，开始执行 run() 方法的线程执行体，则该线程处于运行状态。

如果计算机只有一个 CPU，那么在任何时刻只有一个线程处于运行状态。当然，在一个具有多处理器的机器上，将会有多个线程并行（Parallel）执行；当线程数大于处理器数时，依然会存在多个线程在同一个 CPU 上轮换的情况。

当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了），线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式调度策略的系统而言，系统会给每一个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。

所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机等则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的 sleep() 或 yield() 方法后才会放弃其所占用的资源（也就是必须由该线程主动放弃其所占用的资源）。

当发生如下情况时，线程将会进入阻塞状态：
线程调用 sleep() 方法主动放弃其所占用的处理器资源。
线程调用了一个阻塞式 I/O 方法，在该方法返回之前，该线程被阻塞。
线程试图获得一个锁对象，但该锁对象正被其他线程所持有。关于锁对象的知识，后面将有更深入的介绍。
线程在等待某个通知（Notify）。

当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态，而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。

针对上面几种情况，当发生如下特定的情况时可以解除阻塞，让该线程重新进入就绪状态：
调用 sleep() 方法的线程经过了指定的时间。
线程调用的阻塞式 I/O 方法己经返回。
线程成功地获得了试图获取的锁对象。
线程正在等待某个通知时，其他线程发出了一个通知。