进程是由系统分配资源、线程是由CPU调度(系统级)、协程由用户控制(应用级)

-------

并发和并行的区别：

并发（concurrency）：逻辑上具备同时处理多个任务的能力。
并行（parallesim）：物理上在同一时刻执行多个并发任务，依赖多核处理器等物理设备。
多线程或多进程是并行的基本条件，但单线程也可用协程做到并发。通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。现代系统中，多核 CPU 可以同时运行多个不同的进程或者线程。所以并发程序可以是并行的，也可以不是。

--------

多进程编程和多线程编程，都可以使用并行机制来提升系统的运行效率。二者的区别在于运行时所占的内存分布不同，多钱程是共用一套内存的代码块区间；而多进程是各用一套独立的内存区间。

多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。基于这个特性，常常会用多进程来实现守护服务器的功能。

多进程编程也有不足，即创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。

多线程编程的优点是效率较高一些，适用于批处理任务等功能；不足之处在于，任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。

既然多线程编程和多进程编程各有优缺点，因此它们分别适用于不同的场景。比如说，对于计算密集型的任务，多进程效率会更高一下；而对于IO密集型的任务（比如文件操作，网络爬虫），采用多线程编程效率更高。为什么是这样呢？

其实也不难理解。对于 IO 密集型操作，大部分消耗时间其实是等待时间，在等待时间中，Python会释放GIL供新的线程使用，实现了线程间的切换；相反对于 CPU 密集型代码，2 个 CPU 干活肯定比一个 CPU 快很多。

在大型的计算机集群系统中，通常都会将多进程程序分布运行在不同的计算机上协同工作。而每一台计算机上的进程内部，又会由多个线程来并行工作。

注意，对于任务数来说，无论是多进程编程或者多线程编程，其进程数或线程数都不能太多：
对于多进程编程来说，操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当多的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好；
多线程编程也不是线程个数越多效率越高，通过下面的公式可以计算出线程数量最优的一个参考值。


最佳线程数 = (线程等待时间+线程CPU时间)/线程CPU时间 * CPU数量

-----------

 进程就是一个程序在一个数据集上的一次动态执行过程。
 
 进程一般由程序、数据集、进程控制块三部分组成。
 我们编写的程序用来描述进程要完成哪些功能以及如何完成；数据集则是程序在执行过程中所需要使用的资源；进程控制块用来记录进程的外部特征，描述进程的执行变化过程，系统可以利用它来控制和管理进程，它是系统感知进程存在的唯一标志。

 进程的生命周期：创建（New）、就绪（Runnable）、运行（Running）、阻塞（Block）、销毁（Destroy）
 
 进程的状态（分类）：（Actived）活动进程、可见进程（Visiable）、后台进程（Background）、服务进程（Service）、空进程

--------

多进程与多线程
操作系统会为每个进程分配不同的内存块，而多个线程共享进程的内存块。这带来最直接的不同就是创建线程的开销远小于创建进程的开销。线程是处理器调度的基本单位,但进程不是.
同时，由于内存块不同，所以进程之间的通信相对困难。而线程间的通信简单快速，就是共享进程内的全局变量。
但是，进程的调度由操作系统负责，线程的调度需要我们自己来考虑，避免死锁，饥饿，活锁，资源枯竭等情况的发生，这会增加一定的复杂度，这会增加一定的复杂度。而且，由于线程之间共享内存，我们还需要考虑线程安全性的问题。


--------

线程的生命周期：
1.new新建。新创建的线程经过初始化后，进入Runnable状态。

2.Runnable就绪。等待线程调度。调度后进入运行状态。

3.Running运行。

4.Blocked阻塞，暂停运行，解除阻塞后进入Runnable状态重新等待调度。

5.Dead消亡。线程方法执行完毕返回或者异常终止。

可能有3种情况从Running进入Blocked：
同步：线程中获取同步锁，但是资源已经被其他线程锁定时，进入Locked状态，直到该资源可获取（获取的顺序由Lock队列控制）
睡眠：线程运行sleep()或join()方法后，线程进入Sleeping状态。区别在于sleep等待固定的时间，而join是等待子线程执行完。当然join也可以指定一个“超时时间”。从语义上来说，如果两个线程a,b, 在a中调用b.join()，相当于合并(join)成一个线程。最常见的情况是在主线程中join所有的子线程。
等待：线程中执行wait()方法后，线程进入Waiting状态，等待其他线程的通知(notify）。

线程的类型
主线程：当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通常叫做程序的主线程（Main Thread）。每个进程至少都有一个主线程，主线程通常最后关闭。
子线程：在程序中创建的其他线程，相对于主线程来说就是这个主线程的子线程。
守护线程：daemon thread，对线程的一种标识。守护线程为其他线程提供服务，如JVM的垃圾回收线程。当剩下的全是守护线程时，进程退出。
前台线程：相对于守护线程的其他线程称为前台线程。



---------
一、Python 异步编程的由来
历史上，Python 并不支持异步编程，因为不需要。

有了多线程（threading）和多进程（multiprocessing）[4]，就没必要一定支持异步了。如果一个线程（或进程）阻塞，新建其他线程（或进程）就可以了，程序不会卡死。

但是，多线程有“线程竞争”的问题，处理起来很复杂，还涉及加锁。对于简单的异步任务来说（比如与网页互动），写起来很麻烦。

Python 3.4 引入了 asyncio 模块，增加了异步编程，跟 JavaScript 的async/await 极为类似，大大方便了异步任务的处理。它受到了开发者的欢迎，成为从 Python 2 升级到 Python 3 的主要理由之一。

二、asyncio 的设计
asyncio 模块最大特点就是，只存在一个线程，跟 JavaScript 一样。

由于只有一个线程，就不可能多个任务同时运行。asyncio 是“多任务合作”模式（cooperative multitasking），允许异步任务交出执行权给其他任务，等到其他任务完成，再收回执行权继续往下执行，这跟 JavaScript 也是一样的。

由于代码的执行权在多个任务之间交换，所以看上去好像多个任务同时运行，其实底层只有一个线程，多个任务分享运行时间。

表面上，这是一个不合理的设计，明明有多线程多进程的能力，为什么放着多余的 CPU 核心不用，而只用一个线程呢？但是就像前面说的，单线程简化了很多问题，使得代码逻辑变得简单，写法符合直觉。

asyncio 模块在单线程上启动一个事件循环（event loop），时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束。事件循环的内部机制，可以参考 JavaScript 的模型，两者是一样的。



[并发编程(IO多路复用)](https://www.cnblogs.com/cainingning/p/9556642.html)
[Python多线程的原理与实现](https://blog.csdn.net/daiyu__zz/article/details/81912018)
[Python GIL全局解释器锁详解](http://c.biancheng.net/view/5537.html)